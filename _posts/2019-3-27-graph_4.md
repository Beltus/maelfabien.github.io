---
published: true
title: Graph Learning
collection: st
layout: single
author_profile: false
read_time: true
categories: [machinelearning]
excerpt : "Graph Analysis and Graph Learning"
header :
    overlay_image: "https://maelfabien.github.io/assets/images/wolf.jpg"
    teaser: "https://maelfabien.github.io/assets/images/wolf.jpg"
comments : true
toc: true
toc_sticky: true
---

So far, we covered the main kind of graphs, and the basics of graph analysis. We'll now cover into more details the way we can "learn" in graphs.

<script type="text/javascript" async
    src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-MML-AM_CHTML">
</script>

{% highlight python %}
{% endhighlight %}

For what comes next, open a Jupyter Notebook and import the following packages :

```python
import numpy as np
import random
import networkx as nx
from IPython.display import Image
import matplotlib.pyplot as plt
```

If you have not already installed the `networkx` paxkage, simply run :

```bash
pip install networkx
```

The following articles will be using the latest version  `2.x` of  `networkx`. NetworkX is a Python package for the creation, manipulation, and study of the structure, dynamics, and functions of complex networks.

To illustrate the different concepts we'll cover and how it applies to graphs we'll take the Karate Club example. This graph is present in the `networkx` package. It represents the relations of members of a Karate Club. However, due to a lack a agreement of the founders of the club, the club has recently been splitted in two. We'll try to illustrate this event with graphs. 

First, load and plot the graph :

```python
n=34
m = 78
G_karate = nx.karate_club_graph()

pos = nx.spring_layout(G_karate)
nx.draw(G_karate, cmap = plt.get_cmap('rainbow'), with_labels=True, pos=pos)
```

![image](https://maelfabien.github.io/assets/images/karate.png)

# I. What is Graph Learning ?

There are two main tasks in graph learning :
- link prediction
- node labelling

## Link prediction

In Link Prediction, given a graph $$ G $$, we aim to predict new edges. Predictions are useful to predict future relations or missing edges when the graph is not fully observed for example. 

In link prediction, we simply try to build a similarity measure between pairs of nodes, and link the most similar (up to a threshold $$ k $$ for example). The question is now to identify the right similarity scores !

To illustrate the different similarity scores, let's consider the following graph :

![image](https://maelfabien.github.io/assets/images/graph_13.png)

Let $$ N(i) $$ be a set of neighbors of node $$ i $$. On the graph above, the neighbors of both nodes $$ i $$ and $$ j $$ can be represented as :

![image](https://maelfabien.github.io/assets/images/graph_15.png)

![image](https://maelfabien.github.io/assets/images/graph_16.png)

We can build several similarity scores :
- Common Neigbbors : $$ S(i,j) = \mid N(i) \cap N(j) \mid $$. In this example, the score would be simply 1.

![image](https://maelfabien.github.io/assets/images/graph_17.png)

- Jaccard Coefficient : $$ S(i,j) = \frac { \mid N(i) \cap N(j) \mid } { \mid N(i) \cup N(j) \mid } $$. This is a normalized common neighbors version.

The intersection is the Common Neighbors, and the union is :

![image](https://maelfabien.github.io/assets/images/graph_18.png)

Therefore, the Jaccard Coefficient is given by the ratio :

![image](https://maelfabien.github.io/assets/images/graph_19.png)

And the value is $$ \frac {1} {6} $$.
- Adamic-Adar index : $$ S(i,j) = \sum_{k \in N(i)\cap N(j) } \frac {1}Â {\log \mid N(k) \mid} $$
In other words, for each common neigbbor of nodes $$ i $$ and $$ j $$, sum $$ 1 $$ divided by the total number of neighbors of that node. The concept is that common elements with very large neighbourhoods are less significant when predicting a connection between two nodes compared with elements shared between a small number of nodes.
- Preferential attachement : $$ S(i,j) = \mid N(i,j) \mid * \mid N(j) \mid $$
- We can also use the community information when it is available.

How do we perform the evaluation of the link prediction ?
We must hide a subset of node pairs, and predict their links based on the rules defined above. We then evaluate the proportion or correct predictions for dense graphs, or use Area under the Curve criteria for Sparse graphs.

# Label Propagation

The Label Propagation Algorithm (LPA) is a fast algorithm for finding communities in a graph using network structure alone as its guide, without any predefined objective function or prior information about the communities.

LPA handles semi-supervised learning for label propagation.

![image](https://maelfabien.github.io/assets/images/lpa.png)



> **Conclusion** : I hope that this article was helpful. Don't hesitate to drop a comment if you have any question.

Sources : 
- *A Comprehensive Guide to Graph Algorithms in Neo4j*
- Networkx Documentation
